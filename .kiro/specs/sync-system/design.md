# Архитектура и Дизайн системы синхронизации

## 1. Концепция "Плана обмена"
Архитектура заимствует проверенные подходы распределенных систем (в т.ч. 1С:Предприятие).

*   **Центральная база (Web):** Хранит полную картину всех данных. Является "Мастер-узлом".
*   **Периферийная база (Desktop):** Хранит подмножество данных (или полную копию). Является "Подчиненным узлом".

### 1.1. Топология
`Звезда` (Star Topology). Все десктоп-клиенты синхронизируются только с Центром. Прямой обмен Desktop-Desktop отсутствует.

## 2. Модель данных (Database Schema Changes)

Для реализации механизма требуются системные таблицы, которые не зависят от бизнес-логики.

### 2.1. Таблица Узлов (`sync_nodes`)
Регистрирует участников обмена.

| Поле | Тип | Описание |
|---|---|---|
| `id` | UUID | Уникальный ID узла |
| `code` | String | Код узла (например, "DESKTOP-USER-1") |
| `name` | String | Понятное имя |
| `last_sync_in` | DateTime | Время последней успешной загрузки данных ОТ узла |
| `last_sync_out` | DateTime | Время последней успешной выгрузки данных В узел |
| `received_packet_no` | BigInt | Номер последнего принятого пакета от этого узла |
| `sent_packet_no` | BigInt | Номер последнего отправленного пакета этому узлу (подтвержденного) |

### 2.2. Таблица Регистрации Изменений (`sync_changes`)
"Очередь" изменений. Заполняется триггерами или на уровне ORM (Events) при сохранении объектов.

| Поле | Тип | Описание |
|---|---|---|
| `id` | BigInt (PK) | Глобальный счетчик изменений (Sequence) |
| `node_id` | UUID | FK на sync_nodes. Получатель изменения. |
| `entity_type` | String | Имя модели (e.g., "DailyReport") |
| `entity_uuid` | UUID | ID измененного объекта |
| `operation` | Enum | INSERT / UPDATE / DELETE |
| `packet_no` | BigInt | Номер пакета, в который включено изменение (NULL, если еще не отправлено) |

*Примечание: Для оптимизации можно использовать отдельные таблицы регистрации для каждой сущности (например, `sync_log_daily_report`), но для начала достаточно одной общей таблицы.*

### 2.3. Изменения в Бизнес-сущностях
Во все синхронизируемые таблицы (`daily_reports`, `estimates`, `works`, etc.) добавляются поля:

*   `uuid` (UUID, Unique, Index) — Глобальный ключ.
*   `updated_at` (DateTime) — Время изменения (UTC).
*   `is_deleted` (Boolean) — Признак мягкого удаления (вместо физического DELETE).

## 3. Протокол обмена (JSON Format)

Обмен происходит через HTTP POST запросы.

### 3.1. Структура Пакета (Message Envelope)
Единый формат для запроса и ответа.

```json
{
  "header": {
    "sender_node_id": "uuid-...",
    "recipient_node_id": "uuid-...",
    "packet_no": 105,            // Номер текущего пакета
    "ack_packet_no": 98,         // "Я успешно принял всё до пакета №98 включительно"
    "schema_version": "1.2.0"
  },
  "body": {
    "entities": [
      {
        "type": "DailyReport",
        "uuid": "uuid-...",
        "operation": "UPDATE",
        "data": {
           "date": "2025-12-12",
           "brigade_id": "uuid-...",
           "lines": [ ... ] // Вложенные сущности сериализуются здесь
        }
      },
      {
        "type": "WorkSpecification",
        "uuid": "uuid-...",
        "operation": "DELETE",
        "data": null
      }
    ]
  }
}
```

## 4. Алгоритм синхронизации (Handshake Workflow)

Процесс инициируется Клиентом (Desktop).

### Шаг 1: Клиент -> Сервер (PUSH + ACK)
Клиент собирает все свои локальные изменения, которые еще не были подтверждены сервером.
1.  Выбирает записи из локальной `sync_changes`, где `node_id = SERVER`.
2.  Формирует JSON-пакет с номером `packet_no = last_sent + 1`.
3.  В поле `ack_packet_no` указывает номер последнего успешно принятого пакета от Сервера.
4.  Отправляет POST `/api/sync/exchange`.

### Шаг 2: Сервер (Processing)
1.  **Проверка прав:** Валидация токена узла.
2.  **Обработка ACK:** Сервер видит `ack_packet_no` от клиента. Удаляет из своей таблицы `sync_changes` (для этого узла) все записи с номерами пакетов <= `ack_packet_no`. (Очистка очереди).
3.  **Применение изменений:** Сервер читает `body` пакета.
    *   Применяет изменения к БД в транзакции.
    *   Разрешает конфликты.
    *   Если успешно: обновляет у себя `received_packet_no` для этого клиента.

### Шаг 3: Сервер -> Клиент (PULL + ACK)
Сервер формирует ответный пакет.
1.  Выбирает изменения из `sync_changes`, предназначенные для этого Клиента.
2.  Формирует JSON с новым `packet_no`.
3.  В `ack_packet_no` указывает номер только что принятого пакета от Клиента (квитанция).
4.  Отправляет ответ.

### Шаг 4: Клиент (Finalize)
1.  **Обработка ACK:** Клиент видит подтверждение своих изменений. Удаляет их из локальной регистрации.
2.  **Применение входящих:** Применяет изменения от Сервера.
3.  Запоминает номер пакета сервера как `received_packet_no`.

## 5. Универсальный формат (Generic Serializer)

Чтобы не писать код для каждой сущности, используется Generic Serializer:

1.  **Registry:** Словарь маппинга `{"EntityName": ModelClass}`.
2.  **Serialization:** `Model.to_dict()` метод, который рекурсивно обходит поля.
3.  **Deserialization:** Метод, принимающий dict и обновляющий поля модели по имени.

### Пример реализации сериализатора (Python Pydantic/SQLAlchemy)
```python
def serialize_model(instance):
    return {
        "uuid": str(instance.uuid),
        "updated_at": instance.updated_at.isoformat(),
        **{c.name: getattr(instance, c.name) for c in instance.__table__.columns 
           if c.name not in ['id', 'uuid', 'updated_at']}
    }
```
